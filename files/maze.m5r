<?py
# -*- coding: utf-8 -*-
import tkinter as _tk, math as _m, random as _r, time as _t

def _gen_maze(_lv):
    _sz = min(18 + _lv*4, 50)
    _mp = [[1]*_sz for _ in range(_sz)]
    # Create maze paths
    def _carve(x, y):
        _mp[y][x] = 0
        dirs = [(0,2), (2,0), (0,-2), (-2,0)]
        _r.shuffle(dirs)
        for dx, dy in dirs:
            nx, ny = x + dx, y + dy
            if 2 <= nx < _sz-2 and 2 <= ny < _sz-2 and _mp[ny][nx] == 1:
                _mp[y + dy//2][x + dx//2] = 0
                _carve(nx, ny)
    
    # Start carving from (1,1)
    _carve(1, 1)
    
    # Ensure start and exit are clear
    _mp[1][1] = 0  # start
    _mp[_sz-2][_sz-2] = 2  # exit (blue wall)
    _mp[_sz-3][_sz-2] = 0  # space before exit
    _mp[_sz-2][_sz-3] = 0  # space before exit
    
    return _mp

class _MAZE25D:
    def __init__(self):
        self._rt=_tk.Tk()
        self._rt.title("MAZE 2.5D M5RCode")
        self._W,self._H=1200,820
        self._cv=_tk.Canvas(self._rt,bg="#181319",width=self._W,height=self._H)
        self._cv.pack(fill="both",expand=True)
        self._game_state="main"
        self._rt.bind("<Configure>",self._resize)
        self._rt.bind("<KeyPress>",self._kd)
        self._rt.bind("<KeyRelease>",self._ku)
        self._rt.bind("<Button-1>", self._mouse_btn)
        self._rt.bind("<Escape>",self._esc)
        self._rt.bind("<Motion>", self._mouse_move)
        self._mouse_locked = False
        self._last_mouse_x = None
        self._reset_game()
        self._keys=set()
        self._tick()
        self._rt.mainloop()

    def _reset_game(self,level=1):
        self._level=level
        self._map=_gen_maze(level)
        self._sz=len(self._map)
        self._px,self._py=1.5,1.5  # start position
        self._pa=_m.pi/4
        self._levelup_msg=0

    def _resize(self,e):self._W,self._H=e.width,e.height

    def _mouse_btn(self,e):
        if self._game_state=="main":
            self._game_state="play"
            self._lock_mouse(e)
        elif self._game_state=="pause":
            self._lock_mouse(e)
            self._game_state="play"
            
    def _lock_mouse(self,e=None):
        self._mouse_locked=True
        self._rt.config(cursor="none")
        self._cv.grab_set()
        if e:self._last_mouse_x=e.x
        
    def _unlock_mouse(self,e=None):
        self._mouse_locked=False
        self._rt.config(cursor="")
        self._cv.grab_release()
        self._last_mouse_x=None
        
    def _mouse_move(self,e):
        if self._mouse_locked and self._game_state=="play":
            if self._last_mouse_x:
                self._pa+=(e.x-self._last_mouse_x)*0.005
            self._last_mouse_x=e.x

    def _esc(self,e):
        if self._game_state=="play" and self._mouse_locked:
            self._unlock_mouse()
            self._game_state="pause"
        elif self._game_state=="pause":
            self._game_state="main"
        elif self._game_state=="main":
            self._rt.destroy()

    def _brighten(self, col, factor):
        if col.startswith('#') and len(col)==7:
            r,g,b=int(col[1:3],16),int(col[3:5],16),int(col[5:7],16)
            r,g,b=min(255,int(r*factor)),min(255,int(g*factor)),min(255,int(b*factor))
            return f'#{r:02x}{g:02x}{b:02x}'
        return col
        
    def _darken(self, col, factor):
        if col.startswith('#') and len(col)==7:
            r,g,b=int(col[1:3],16),int(col[3:5],16),int(col[5:7],16)
            r,g,b=int(r*factor),int(g*factor),int(b*factor)
            return f'#{r:02x}{g:02x}{b:02x}'
        return col

    def _draw_3d_box(self,x,y,w,h,d,col,ol='#000000'):
        self._cv.create_rectangle(x,y,x+w,y+h,fill=col,outline=ol,width=2)
        pts_top=[(x,y),(x+d,y-d),(x+w+d,y-d),(x+w,y)]
        self._cv.create_polygon(pts_top,fill=self._brighten(col,1.22),outline=ol,width=1)
        pts_r=[(x+w,y),(x+w+d,y-d),(x+w+d,y+h-d),(x+w,y+h)]
        self._cv.create_polygon(pts_r,fill=self._darken(col,0.75),outline=ol,width=1)

    def _draw_hud(self):
        y = self._H-80
        self._draw_3d_box(0,y,self._W,80,6,"#161b28","#313c32")
        
        # Level display
        self._cv.create_text(120,y+25,text=f"LEVEL: {self._level}",font=("Consolas",24,"bold"),fill="#00ffcc")
        
        # Instructions
        self._cv.create_text(self._W//2,y+25,text="FIND THE BLUE EXIT!",font=("Consolas",20,"bold"),fill="#ffff44")
        
        # Size info
        self._cv.create_text(self._W-150,y+25,text=f"MAZE SIZE: {self._sz}x{self._sz}",font=("Consolas",16,"bold"),fill="#ff6644")

    def _raycast(self,a):
        x,y = self._px,self._py
        dx,dy = _m.cos(a)*.05,_m.sin(a)*.05
        for d in range(1,400):
            x+=dx; y+=dy
            mx,my=int(x),int(y)
            if mx<0 or my<0 or mx>=self._sz or my>=self._sz: 
                return d/20,1,'#666666'
            cell = self._map[my][mx]
            if cell==1: 
                return d/20,1,'#888888'
            elif cell==2:  # Blue exit wall
                return d/20,1,'#0066ff'
        return 18,0,'#000000'

    def _render_game(self):
        w,h = self._W,self._H
        self._cv.delete('all')
        
        # Sky gradient
        for i in range(h//2):
            b=45+i//12
            sh=f"#{b:02x}{b:02x}{b//2+20:02x}"
            self._cv.create_line(0,i,w,i,fill=sh)
            
        # Floor gradient  
        for i in range(h//2,h):
            b=70-(i-h//2)//10
            sh=f"#{b:02x}{b//3:02x}{b//4:02x}"
            self._cv.create_line(0,i,w,i,fill=sh)
        
        # Render walls
        rays=250
        for i in range(rays):
            a=self._pa-_m.pi/2.3 + (_m.pi/1.15*i)/(rays-1)
            d,wall,wall_color=self._raycast(a)
            d = max(.08, d*_m.cos(a-self._pa))
            hwall=int(h*0.8/d)
            
            if wall:
                # Apply distance shading to wall color
                if wall_color == '#0066ff':  # Blue exit wall
                    shade_factor = max(0.3, min(1.0, 1.0/d))
                    r,g,b = 0, int(102*shade_factor), int(255*shade_factor)
                    cc = f"#{r:02x}{g:02x}{b:02x}"
                else:  # Regular walls
                    shade=min(255,max(30,int(200/(d+0.8))))
                    cc=f"#{shade:02x}{shade:02x}{shade:02x}"
            else:
                cc="#000000"
                
            x=int(i*w/rays)
            self._cv.create_rectangle(x,h//2-hwall//2-10,x+int(w/rays+1),h//2+hwall//2,fill=cc,outline="")
        
        self._draw_hud()
        
        # Compass/minimap indicator
        cx,cy=w-80,80
        self._cv.create_oval(cx-30,cy-30,cx+30,cy+30,fill="#333333",outline="#ffffff",width=2)
        # Direction arrow
        arrow_x = cx + 20*_m.cos(self._pa)
        arrow_y = cy + 20*_m.sin(self._pa)
        self._cv.create_line(cx,cy,arrow_x,arrow_y,fill="#00ff00",width=3)
        self._cv.create_text(cx,cy+45,text="N",font=("Consolas",12,"bold"),fill="#ffffff")
        
        if self._game_state=="pause":
            self._draw_3d_box(w//2-150,h//2-70,300,69,10,"#333333","#242424")
            self._cv.create_text(w//2,h//2-37,text="PAUSED",font=("Consolas",28,"bold"),fill="#ffff44")
            self._cv.create_text(w//2,h//2+7,text="ESC to resume",font=("Consolas",13,"bold"),fill="#66ccdd")
            
        if self._levelup_msg>0:
            self._draw_3d_box(w//2-180,h//2-60,360,50,12,"#0066ff","#ffffff")
            self._cv.create_text(w//2,h//2-35,text=f"LEVEL {self._level-1} COMPLETE!",font=("Consolas",18,"bold"),fill="#ffffff")
            self._levelup_msg-=1

    def _tick(self):
        if self._game_state=="play": 
            self._step()
            self._render_game()
        elif self._game_state=="main": 
            self._render_menu()
        elif self._game_state=="pause": 
            self._render_game()
        self._rt.after(30,self._tick)
        
    def _render_menu(self):
        w,h=self._W,self._H
        self._cv.delete('all')
        
        # Checkered background
        for y in range(0,h,80):
            for x in range(0,w,80):
                cc="#2a3344" if (x//80+y//80)%2==0 else "#1a2233"
                self._cv.create_rectangle(x,y,x+80,y+80,fill=cc,width=0)
        
        # Title
        self._draw_3d_box(w//2-200,h//3-100,400,80,25,"#0066ff","#003388")
        self._cv.create_text(w//2,h//3-60,text="MAZE ESCAPE",fill="#ffffff",font=("Consolas",36,"bold"))
        
        # Subtitle
        self._draw_3d_box(w//2-180,h//3,360,50,15,"#44aa44","#226622")
        self._cv.create_text(w//2,h//3+25,text="2.5D ADVENTURE",fill="#ffffff",font=("Consolas",20,"bold"))
        
        # Start button
        self._draw_3d_box(w//2-120,h//2+80,240,55,12,"#ff6644","#ffffff")
        self._cv.create_text(w//2,h//2+107,text="START MAZE",fill="#ffffff",font=("Consolas",18,"bold"))
        
        # Instructions
        self._cv.create_text(w//2,h-80,text="Find the BLUE WALL to escape each level!",font=("Consolas",16),fill="#aaccff")
        self._cv.create_text(w//2,h-50,text="WASD: Move | Mouse: Look | Click: Lock Camera",font=("Consolas",14),fill="#88aacc")

    def _move_smooth(self,dx,dy):
        def is_blocked(x,y):
            mx,my=int(x),int(y)
            return mx<0 or my<0 or mx>=self._sz or my>=self._sz or self._map[my][mx]==1
            
        nx,ny = self._px+dx, self._py+dy
        if not is_blocked(nx,ny):
            self._px, self._py = nx,ny
        else:
            # Try sliding along walls
            if not is_blocked(self._px,ny): 
                self._py=ny
            elif not is_blocked(nx,self._py): 
                self._px=nx

    def _step(self):
        # Movement
        spd,dx,dy=0.12,0,0
        if 'w' in self._keys: 
            dx+=_m.cos(self._pa)*spd
            dy+=_m.sin(self._pa)*spd
        if 's' in self._keys: 
            dx-=_m.cos(self._pa)*spd*.8
            dy-=_m.sin(self._pa)*spd*.8
        if 'a' in self._keys: 
            dx+=_m.cos(self._pa-_m.pi/2)*spd*.7
            dy+=_m.sin(self._pa-_m.pi/2)*spd*.7
        if 'd' in self._keys: 
            dx+=_m.cos(self._pa+_m.pi/2)*spd*.7
            dy+=_m.sin(self._pa+_m.pi/2)*spd*.7
            
        self._move_smooth(dx,dy)
        
        # Check if player reached the blue exit wall
        mx, my = int(self._px), int(self._py)
        
        # Check surrounding cells for the exit (blue wall)
        for check_x in range(max(0, mx-1), min(self._sz, mx+2)):
            for check_y in range(max(0, my-1), min(self._sz, my+2)):
                if self._map[check_y][check_x] == 2:
                    # Close enough to exit
                    distance = _m.sqrt((self._px - (check_x+0.5))**2 + (self._py - (check_y+0.5))**2)
                    if distance < 1.2:
                        self._reset_game(self._level + 1)
                        self._levelup_msg = 60
                        return

    def _kd(self,e):
        if self._game_state=="play" and self._mouse_locked: 
            self._keys.add(e.keysym.lower())
        if e.keysym.lower()=='left': 
            self._pa-=_m.pi/20
        if e.keysym.lower()=='right': 
            self._pa+=_m.pi/20
            
    def _ku(self,e): 
        self._keys.discard(e.keysym.lower())

_MAZE25D()
?>

<?js
console.log("MAZE ESCAPE 2.5D M5RCode");
?>

<?php
echo "MAZE ESCAPE 2.5D M5RCode\n";
?>

<?cs
using System;
class _M{
 static void Main(){ Console.WriteLine("MAZE ESCAPE 2.5D M5RCode"); }
}
?>

<?cpp
#include <iostream>
int main(){ std::cout<<"MAZE ESCAPE 2.5D M5RCode"<<std::endl; return 0;}
?>

<?css
body{background:#1a2233;color:#fff;font-family:'Courier New',monospace;overflow:hidden;}
canvas{cursor:crosshair;image-rendering:pixelated;}
.maze-wall{filter:contrast(1.1);}
.maze-exit{filter:brightness(1.3) saturate(1.5);}
?>
